import { useEffect, useMemo, useRef, useState } from 'react'
import { Card, Button, Typography, Space, Input, Progress, message, Alert, Row, Col, List, Tag, Popconfirm, Modal } from 'antd'
import { useAppDispatch, useAppSelector } from '../hooks'
import { initInterview, addMessage, startQuestion, answerQuestion, setGrading, endInterview } from '../slices/chatSlice'
// session slice imports not needed here currently
import { generateQuestions as genQ, scoreAnswer as scoreQ, finalizeCandidate as finalizeProv } from '../utils/hfClient'
import type { Question } from '../types'
import { setFinalResult } from '../slices/candidatesSlice'

export default function ChatStep() {
  const dispatch = useAppDispatch()
  const activeId = useAppSelector((s) => s.session.activeCandidateId)
  const interview = useAppSelector((s) => (activeId ? s.chat.interviews[activeId] : undefined))
  useAppSelector((s) => s.chat.messages) // ensure updates re-render
  const candidate = useAppSelector((s) => (activeId ? s.candidates.byId[activeId] : undefined))
  const currentTestId = useAppSelector((s) => s.session.currentTestId)
  const tests = useAppSelector((s) => s.tests)
  const jd = currentTestId ? tests.byId[currentTestId]?.jobDescription : undefined
  const chatMessages = useAppSelector((s) => (activeId ? s.chat.messages[activeId] ?? [] : []))
  const [answer, setAnswer] = useState('')
  const [remaining, setRemaining] = useState<number | null>(null)
  const timerRef = useRef<number | null>(null)
  const [resultOpen, setResultOpen] = useState(false)
  const [starting, setStarting] = useState(false)
  const [startError, setStartError] = useState<string | null>(null)

  const handleStartInterview = async () => {
    if (!activeId || !candidate) return
    setStarting(true)
    try {
      setStartError(null)
      message.loading({ content: 'Contacting AI to generate questions...', key: 'start', duration: 0 })
      const qs = await genQ(candidate.profile.jobRole, jd)
      if (!Array.isArray(qs) || qs.length < 6) throw new Error('AI did not return 6 questions')
      dispatch(
        initInterview({
          candidateId: activeId,
          questions: qs,
          meta: { jobRole: candidate.profile.jobRole, testId: currentTestId, source: 'remote' },
        })
      )
      dispatch(
        addMessage({
          candidateId: activeId,
          message: {
            role: 'ai',
            content:
              'Welcome! We will proceed with 6 questions: 2 easy, 2 medium, 2 hard. Answer within the time limit.',
          },
        })
      )
      message.success({ content: 'Questions generated by AI.', key: 'start', duration: 2 })
    } catch (e) {
      const errMsg = (e as Error)?.message || 'Failed to start interview.'
      setStartError(errMsg)
      message.error({ content: errMsg, key: 'start', duration: 4 })
    } finally {
      setStarting(false)
    }
  }

  const currentQuestion: Question | undefined = useMemo(() => {
    if (!interview) return undefined
    return interview.questions[interview.currentIndex]
  }, [interview])

  // Regeneration disabled: interview questions are set when starting.

  // Handle timer
  useEffect(() => {
    if (!activeId || !currentQuestion) return
    if (!currentQuestion.startedAt) {
      dispatch(startQuestion({ candidateId: activeId, questionId: currentQuestion.id }))
      // log question to chat
      dispatch(addMessage({ candidateId: activeId, message: { role: 'ai', content: currentQuestion.text } }))
    }
    const startedAt = currentQuestion.startedAt ?? Date.now()
    const endAt = startedAt + currentQuestion.durationSec * 1000
    const tick = () => {
      const now = Date.now()
      const rem = Math.max(0, Math.floor((endAt - now) / 1000))
      setRemaining(rem)
      if (now >= endAt) {
        window.clearInterval(timerRef.current ?? undefined)
        timerRef.current = null
        // Auto submit
        const base = answer.trim()
        const ans = currentQuestion.difficulty === 'easy' ? (base.split(/\s+/)[0] || '') : base
        dispatch(addMessage({ candidateId: activeId, message: { role: 'user', content: ans || '(no answer provided)' } }))
        dispatch(answerQuestion({ candidateId: activeId, questionId: currentQuestion.id, answer: ans, autoSubmitted: true }))
      }
    }
    tick()
    timerRef.current = window.setInterval(tick, 250)
    return () => {
      if (timerRef.current) window.clearInterval(timerRef.current)
      timerRef.current = null
    }
  }, [activeId, currentQuestion?.id, currentQuestion, dispatch, answer])

  useEffect(() => {
    // Grade last answered question
    if (!activeId || !interview) return
    const last = interview.questions[interview.currentIndex - 1]
    if (last && last.answer && last.score == null) {
      ;(async () => {
        try {
          const { score, feedback, points } = await scoreQ(last, last.answer!)
          // Store both legacy score (0-10) and new points
          dispatch(setGrading({ candidateId: activeId, questionId: last.id, score, feedback, points }))
          const maxPts = last.maxPoints ?? 10
          dispatch(addMessage({ candidateId: activeId, message: { role: 'ai', content: `Feedback: ${feedback} (Points: ${points}/${maxPts})` } }))
        } catch {
          message.error('Scoring failed. Please try again later.')
        }
      })()
    }
    // If interview ended naturally (not via manual finalize below), finalize here
    if (interview.complete && candidate && candidate.profile.finalScore == null) {
      ;(async () => {
        const { finalScore, summary } = await finalizeProv(candidate.profile, interview.questions)
        dispatch(setFinalResult({ id: candidate.profile.id, finalScore, summary }))
        message.success('Interview complete!')
        setResultOpen(true)
      })()
    }
  }, [activeId, candidate, dispatch, interview])

  if (!activeId)
    return <Alert type="info" message="Please upload a resume and save details first." showIcon />

  // Missing fields form
  const p = candidate?.profile
  const missing: Array<'name' | 'email' | 'phone' | 'jobRole'> = []
  if (!p?.name) missing.push('name')
  if (!p?.email) missing.push('email')
  if (!p?.phone) missing.push('phone')
  if (!p?.jobRole) missing.push('jobRole')

  if (missing.length > 0) {
    return (
      <Card title="Interview Chat">
        <Alert
          type="warning"
          showIcon
          message="Please complete your details first"
          description="Go to the '1. Resume & Details' tab and fill your Name, Email, Phone, and Job Role. Once saved, return here to start the interview."
        />
      </Card>
    )
  }

  if (!interview) {
    return (
      <Card title="Interview Chat">
        <Space direction="vertical" size="middle">
          <Typography.Paragraph>
            When you are ready, click Start Interview. You will get 6 questions (2 easy, 2 medium, 2 hard). Each has a time limit. Ensure your job role is set correctly to receive role-specific questions.
          </Typography.Paragraph>
          <Button 
            type="primary" 
            onClick={handleStartInterview} 
            loading={starting}
            size="large"
            style={{
              borderRadius: '8px',
              background: starting 
                ? 'linear-gradient(135deg, #d9d9d9 0%, #bfbfbf 100%)'
                : 'linear-gradient(135deg, #52c41a 0%, #389e0d 100%)',
              border: 'none',
              fontWeight: 600,
              boxShadow: starting 
                ? '0 2px 6px rgba(0, 0, 0, 0.1)'
                : '0 4px 12px rgba(82, 196, 26, 0.3)',
              transition: 'all 0.3s ease',
              minWidth: '140px',
              minHeight: '48px'
            }}
            onMouseEnter={(e) => {
              if (!starting) {
                e.currentTarget.style.transform = 'translateY(-2px)'
                e.currentTarget.style.boxShadow = '0 6px 16px rgba(82, 196, 26, 0.4)'
              }
            }}
            onMouseLeave={(e) => {
              if (!starting) {
                e.currentTarget.style.transform = 'translateY(0)'
                e.currentTarget.style.boxShadow = '0 4px 12px rgba(82, 196, 26, 0.3)'
              }
            }}
          >
            Start Interview
          </Button>
          {startError && (
            <Alert type="error" showIcon message="Could not start the interview" description={startError} />
          )}
        </Space>
      </Card>
    )
  }

  const onSubmit = () => {
    if (!activeId || !currentQuestion) return
    // For easy questions, enforce one-word answer by taking the first token
    const ans = currentQuestion.difficulty === 'easy' ? (answer.trim().split(/\s+/)[0] || '') : answer.trim()
    dispatch(addMessage({ candidateId: activeId, message: { role: 'user', content: ans || '(no answer provided)' } }))
    dispatch(answerQuestion({ candidateId: activeId, questionId: currentQuestion.id, answer: ans }))
    setAnswer('')
  }

  const percent = currentQuestion && remaining != null
    ? Math.round(((currentQuestion.durationSec - remaining) / currentQuestion.durationSec) * 100)
    : 0

  return (
    <Card
      title={`Question ${Math.min(interview.currentIndex + 1, interview.questions.length)} of ${interview.questions.length}`}
      extra={
        <Space>
          <span style={{ minWidth: 160, display: 'inline-block' }}>Time Left: {remaining ?? 0}s</span>
          <Popconfirm
            title="End interview now?"
            description="This will stop the interview early and finalize the candidate based on answered questions."
            okText="Yes, end now"
            cancelText="Cancel"
            onConfirm={async () => {
              if (!activeId || !interview || !candidate) return
              // Grade any answered but unscored questions first (compute a copy for finalize)
              const gradedForFinalize: Question[] = interview.questions.map((q: Question) => ({ ...q }))
              for (const q of gradedForFinalize) {
                if (q.answer && q.score == null) {
                  const { score, feedback } = await scoreQ(q, q.answer)
                  q.score = score
                  q.feedback = feedback
                  dispatch(setGrading({ candidateId: activeId, questionId: q.id, score, feedback }))
                }
              }
              // Mark interview ended
              dispatch(endInterview({ candidateId: activeId, reason: 'manual' }))
              dispatch(addMessage({ candidateId: activeId, message: { role: 'meta', content: 'Interview ended early by interviewer.' } }))
              // Finalize
              const { finalScore, summary } = await finalizeProv(candidate.profile, gradedForFinalize)
              dispatch(setFinalResult({ id: candidate.profile.id, finalScore, summary }))
              message.success('Interview ended and finalized.')
              setResultOpen(true)
            }}
          >
            <Button danger>End Interview</Button>
          </Popconfirm>
        </Space>
      }
    >
      {currentQuestion ? (
        <Row gutter={[8, 16]}>
          <Col xs={24} lg={16}>
            <Space direction="vertical" size="middle" style={{ width: '100%' }}>
              <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
                <Tag 
                  color={currentQuestion.difficulty === 'easy' ? 'green' : currentQuestion.difficulty === 'medium' ? 'orange' : 'red'}
                  style={{ alignSelf: 'flex-start' }}
                >
                  {currentQuestion.difficulty.toUpperCase()}
                </Tag>
                <Typography.Paragraph style={{ margin: 0, fontSize: '14px', lineHeight: '1.5' }}>
                  {currentQuestion.text}
                </Typography.Paragraph>
              </div>
              <Progress percent={percent} status={remaining === 0 ? 'exception' : 'active'} />
              {currentQuestion.difficulty === 'easy' ? (
                <Input
                  value={answer}
                  onChange={(e) => setAnswer((e.target.value || '').trim().split(/\s+/)[0] || '')}
                  placeholder="Type a single-word answer…"
                  maxLength={40}
                  onPressEnter={onSubmit}
                  size="large"
                />
              ) : (
                <Input.TextArea
                  value={answer}
                  onChange={(e) => setAnswer(e.target.value)}
                  rows={3}
                  placeholder="Type your answer here..."
                  size="large"
                />
              )}
              <Button 
                type="primary" 
                onClick={onSubmit} 
                disabled={remaining === 0} 
                style={{ 
                  width: '100%',
                  borderRadius: '8px',
                  background: remaining === 0 
                    ? 'linear-gradient(135deg, #d9d9d9 0%, #bfbfbf 100%)'
                    : 'linear-gradient(135deg, #1890ff 0%, #096dd9 100%)',
                  border: 'none',
                  fontWeight: 600,
                  boxShadow: remaining === 0 
                    ? '0 2px 6px rgba(0, 0, 0, 0.1)'
                    : '0 4px 12px rgba(24, 144, 255, 0.3)',
                  transition: 'all 0.3s ease',
                  minHeight: '48px'
                }}
                size="large"
                onMouseEnter={(e) => {
                  if (remaining !== 0) {
                    e.currentTarget.style.transform = 'translateY(-2px)'
                    e.currentTarget.style.boxShadow = '0 6px 16px rgba(24, 144, 255, 0.4)'
                  }
                }}
                onMouseLeave={(e) => {
                  if (remaining !== 0) {
                    e.currentTarget.style.transform = 'translateY(0)'
                    e.currentTarget.style.boxShadow = '0 4px 12px rgba(24, 144, 255, 0.3)'
                  }
                }}
              >
                Submit answer
              </Button>
              <div style={{ marginTop: '16px' }}>
                {interview.questions.slice(0, interview.currentIndex).map((q: Question) => (
                  <div key={q.id} style={{ 
                    marginBottom: '12px', 
                    padding: '8px', 
                    backgroundColor: '#f5f5f5', 
                    borderRadius: '4px',
                    fontSize: '12px'
                  }}>
                    <div style={{ display: 'flex', alignItems: 'center', gap: '8px', marginBottom: '4px' }}>
                      <Tag 
                        color={q.difficulty === 'easy' ? 'green' : q.difficulty === 'medium' ? 'orange' : 'red'}
                        style={{ margin: 0, fontSize: '10px' }}
                      >
                        {q.difficulty.toUpperCase()}
                      </Tag>
                      {q.score != null && (
                        <Typography.Text style={{ fontSize: '11px' }}>
                          Score: {q.score}/10
                        </Typography.Text>
                      )}
                    </div>
                    {q.feedback && (
                      <Typography.Text style={{ fontSize: '11px', color: '#666' }}>
                        {q.feedback}
                      </Typography.Text>
                    )}
                  </div>
                ))}
                {interview.complete && candidate?.profile.finalScore != null && (
                  <div style={{ 
                    marginTop: '16px', 
                    padding: '12px', 
                    backgroundColor: '#e6f7ff', 
                    borderRadius: '4px'
                  }}>
                    <Typography.Text strong>
                      Final Score: {candidate.profile.finalScore}
                    </Typography.Text>
                    {candidate.profile.summary && (
                      <Typography.Paragraph style={{ margin: '4px 0 0 0', fontSize: '12px' }}>
                        {candidate.profile.summary}
                      </Typography.Paragraph>
                    )}
                  </div>
                )}
              </div>
            </Space>
          </Col>
          <Col xs={24} lg={8}>
            <div style={{ marginTop: window.innerWidth < 992 ? '16px' : '0' }}>
              <Typography.Title level={5} style={{ margin: '0 0 8px 0' }}>Chat</Typography.Title>
              <List
                size="small"
                bordered
                dataSource={chatMessages.slice(-10)}
                renderItem={(m: typeof chatMessages[number]) => (
                  <List.Item style={{ padding: '6px 8px' }}>
                    <div style={{ width: '100%' }}>
                      <Typography.Text strong style={{ fontSize: '11px', color: '#666' }}>
                        {m.role.toUpperCase()}:
                      </Typography.Text>
                      <Typography.Text style={{ fontSize: '12px', display: 'block', marginTop: '2px' }}>
                        {m.content}
                      </Typography.Text>
                    </div>
                  </List.Item>
                )}
                style={{ 
                  maxHeight: window.innerWidth < 992 ? 200 : 300, 
                  overflow: 'auto' 
                }}
              />
            </div>
          </Col>
        </Row>
      ) : (
        <Alert type="success" message="Interview finished!" />
      )}
      <Modal
        title="Your Result"
        open={resultOpen}
        onOk={() => setResultOpen(false)}
        onCancel={() => setResultOpen(false)}
        okText="Close"
        cancelButtonProps={{ style: { display: 'none' } }}
      >
        {candidate?.profile.finalScore != null ? (
          <Space direction="vertical">
            <Typography.Title level={4} style={{ margin: 0 }}>Score: {candidate.profile.finalScore}</Typography.Title>
            {candidate.profile.summary && <Typography.Paragraph>{candidate.profile.summary}</Typography.Paragraph>}
          </Space>
        ) : (
          <Typography.Paragraph>Calculating your result...</Typography.Paragraph>
        )}
      </Modal>
    </Card>
  )
}
