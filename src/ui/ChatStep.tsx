import { useEffect, useMemo, useRef, useState } from 'react'
import { Card, Button, Typography, Space, Input, Progress, message, Alert, Row, Col, List, Tag, Popconfirm, Modal } from 'antd'
import { useAppDispatch, useAppSelector } from '../hooks'
import { initInterview, addMessage, startQuestion, answerQuestion, setGrading, endInterview } from '../slices/chatSlice'
// session slice imports not needed here currently
import { generateQuestions as genQ, scoreAnswer as scoreQ, finalizeCandidate as finalizeProv } from '../utils/hfClient'
import type { Question } from '../types'
import { setFinalResult } from '../slices/candidatesSlice'

export default function ChatStep() {
  const dispatch = useAppDispatch()
  const activeId = useAppSelector((s) => s.session.activeCandidateId)
  const interview = useAppSelector((s) => (activeId ? s.chat.interviews[activeId] : undefined))
  useAppSelector((s) => s.chat.messages) // ensure updates re-render
  const candidate = useAppSelector((s) => (activeId ? s.candidates.byId[activeId] : undefined))
  const currentTestId = useAppSelector((s) => s.session.currentTestId)
  const tests = useAppSelector((s) => s.tests)
  const jd = currentTestId ? tests.byId[currentTestId]?.jobDescription : undefined
  const chatMessages = useAppSelector((s) => (activeId ? s.chat.messages[activeId] ?? [] : []))
  const [answer, setAnswer] = useState('')
  const [remaining, setRemaining] = useState<number | null>(null)
  const timerRef = useRef<number | null>(null)
  const [resultOpen, setResultOpen] = useState(false)
  const [starting, setStarting] = useState(false)
  const [startError, setStartError] = useState<string | null>(null)

  const handleStartInterview = async () => {
    if (!activeId || !candidate) return
    setStarting(true)
    try {
      setStartError(null)
      message.loading({ content: 'Contacting AI to generate questions...', key: 'start', duration: 0 })
      const qs = await genQ(candidate.profile.jobRole, jd)
      if (!Array.isArray(qs) || qs.length < 6) throw new Error('AI did not return 6 questions')
      dispatch(
        initInterview({
          candidateId: activeId,
          questions: qs,
          meta: { jobRole: candidate.profile.jobRole, testId: currentTestId, source: 'remote' },
        })
      )
      dispatch(
        addMessage({
          candidateId: activeId,
          message: {
            role: 'ai',
            content:
              'Welcome! We will proceed with 6 questions: 2 easy, 2 medium, 2 hard. Answer within the time limit.',
          },
        })
      )
      message.success({ content: 'Questions generated by AI.', key: 'start', duration: 2 })
    } catch (e) {
      const errMsg = (e as Error)?.message || 'Failed to start interview.'
      setStartError(errMsg)
      message.error({ content: errMsg, key: 'start', duration: 4 })
    } finally {
      setStarting(false)
    }
  }

  const currentQuestion: Question | undefined = useMemo(() => {
    if (!interview) return undefined
    return interview.questions[interview.currentIndex]
  }, [interview])

  // Regeneration disabled: interview questions are set when starting.

  // Handle timer
  useEffect(() => {
    if (!activeId || !currentQuestion) return
    if (!currentQuestion.startedAt) {
      dispatch(startQuestion({ candidateId: activeId, questionId: currentQuestion.id }))
      // log question to chat
      dispatch(addMessage({ candidateId: activeId, message: { role: 'ai', content: currentQuestion.text } }))
    }
    const startedAt = currentQuestion.startedAt ?? Date.now()
    const endAt = startedAt + currentQuestion.durationSec * 1000
    const tick = () => {
      const now = Date.now()
      const rem = Math.max(0, Math.floor((endAt - now) / 1000))
      setRemaining(rem)
      if (now >= endAt) {
        window.clearInterval(timerRef.current ?? undefined)
        timerRef.current = null
        // Auto submit
        const base = answer.trim()
        const ans = currentQuestion.difficulty === 'easy' ? (base.split(/\s+/)[0] || '') : base
        dispatch(addMessage({ candidateId: activeId, message: { role: 'user', content: ans || '(no answer provided)' } }))
        dispatch(answerQuestion({ candidateId: activeId, questionId: currentQuestion.id, answer: ans, autoSubmitted: true }))
      }
    }
    tick()
    timerRef.current = window.setInterval(tick, 250)
    return () => {
      if (timerRef.current) window.clearInterval(timerRef.current)
      timerRef.current = null
    }
  }, [activeId, currentQuestion?.id, currentQuestion, dispatch, answer])

  useEffect(() => {
    // Grade last answered question
    if (!activeId || !interview) return
    const last = interview.questions[interview.currentIndex - 1]
    if (last && last.answer && last.score == null) {
      ;(async () => {
        try {
          const { score, feedback, points } = await scoreQ(last, last.answer!)
          // Store both legacy score (0-10) and new points
          dispatch(setGrading({ candidateId: activeId, questionId: last.id, score, feedback, points }))
          const maxPts = last.maxPoints ?? 10
          dispatch(addMessage({ candidateId: activeId, message: { role: 'ai', content: `Feedback: ${feedback} (Points: ${points}/${maxPts})` } }))
        } catch {
          message.error('Scoring failed. Please try again later.')
        }
      })()
    }
    // If interview ended naturally (not via manual finalize below), finalize here
    if (interview.complete && candidate && candidate.profile.finalScore == null) {
      ;(async () => {
        const { finalScore, summary } = await finalizeProv(candidate.profile, interview.questions)
        dispatch(setFinalResult({ id: candidate.profile.id, finalScore, summary }))
        message.success('Interview complete!')
        setResultOpen(true)
      })()
    }
  }, [activeId, candidate, dispatch, interview])

  if (!activeId)
    return <Alert type="info" message="Please upload a resume and save details first." showIcon />

  // Missing fields form
  const p = candidate?.profile
  const missing: Array<'name' | 'email' | 'phone' | 'jobRole'> = []
  if (!p?.name) missing.push('name')
  if (!p?.email) missing.push('email')
  if (!p?.phone) missing.push('phone')
  if (!p?.jobRole) missing.push('jobRole')

  if (missing.length > 0) {
    return (
      <Card title="Interview Chat">
        <Alert
          type="warning"
          showIcon
          message="Please complete your details first"
          description="Go to the '1. Resume & Details' tab and fill your Name, Email, Phone, and Job Role. Once saved, return here to start the interview."
        />
      </Card>
    )
  }

  if (!interview) {
    return (
      <Card title="Interview Chat">
        <Space direction="vertical" size="middle">
          <Typography.Paragraph>
            When you are ready, click Start Interview. You will get 6 questions (2 easy, 2 medium, 2 hard). Each has a time limit. Ensure your job role is set correctly to receive role-specific questions.
          </Typography.Paragraph>
          <Button type="primary" onClick={handleStartInterview} loading={starting}>
            Start Interview
          </Button>
          {startError && (
            <Alert type="error" showIcon message="Could not start the interview" description={startError} />
          )}
        </Space>
      </Card>
    )
  }

  const onSubmit = () => {
    if (!activeId || !currentQuestion) return
    // For easy questions, enforce one-word answer by taking the first token
    const ans = currentQuestion.difficulty === 'easy' ? (answer.trim().split(/\s+/)[0] || '') : answer.trim()
    dispatch(addMessage({ candidateId: activeId, message: { role: 'user', content: ans || '(no answer provided)' } }))
    dispatch(answerQuestion({ candidateId: activeId, questionId: currentQuestion.id, answer: ans }))
    setAnswer('')
  }

  const percent = currentQuestion && remaining != null
    ? Math.round(((currentQuestion.durationSec - remaining) / currentQuestion.durationSec) * 100)
    : 0

  return (
    <Card
      title={`Question ${Math.min(interview.currentIndex + 1, interview.questions.length)} of ${interview.questions.length}`}
      extra={
        <Space>
          <span style={{ minWidth: 160, display: 'inline-block' }}>Time Left: {remaining ?? 0}s</span>
          <Popconfirm
            title="End interview now?"
            description="This will stop the interview early and finalize the candidate based on answered questions."
            okText="Yes, end now"
            cancelText="Cancel"
            onConfirm={async () => {
              if (!activeId || !interview || !candidate) return
              // Grade any answered but unscored questions first (compute a copy for finalize)
              const gradedForFinalize: Question[] = interview.questions.map((q: Question) => ({ ...q }))
              for (const q of gradedForFinalize) {
                if (q.answer && q.score == null) {
                  const { score, feedback } = await scoreQ(q, q.answer)
                  q.score = score
                  q.feedback = feedback
                  dispatch(setGrading({ candidateId: activeId, questionId: q.id, score, feedback }))
                }
              }
              // Mark interview ended
              dispatch(endInterview({ candidateId: activeId, reason: 'manual' }))
              dispatch(addMessage({ candidateId: activeId, message: { role: 'meta', content: 'Interview ended early by interviewer.' } }))
              // Finalize
              const { finalScore, summary } = await finalizeProv(candidate.profile, gradedForFinalize)
              dispatch(setFinalResult({ id: candidate.profile.id, finalScore, summary }))
              message.success('Interview ended and finalized.')
              setResultOpen(true)
            }}
          >
            <Button danger>End Interview</Button>
          </Popconfirm>
        </Space>
      }
    >
      {currentQuestion ? (
        <Row gutter={16}>
          <Col xs={24} md={16}>
            <Space direction="vertical" size="large" style={{ width: '100%' }}>
              <div>
                <Tag color={currentQuestion.difficulty === 'easy' ? 'green' : currentQuestion.difficulty === 'medium' ? 'orange' : 'red'}>
                  {currentQuestion.difficulty.toUpperCase()}
                </Tag>
                <Typography.Paragraph style={{ display: 'inline', marginLeft: 8 }}>{currentQuestion.text}</Typography.Paragraph>
              </div>
              <Progress percent={percent} status={remaining === 0 ? 'exception' : 'active'} />
              {currentQuestion.difficulty === 'easy' ? (
                <Input
                  value={answer}
                  onChange={(e) => setAnswer((e.target.value || '').trim().split(/\s+/)[0] || '')}
                  placeholder="Type a single-word answer…"
                  maxLength={40}
                  onPressEnter={onSubmit}
                />
              ) : (
                <Input.TextArea
                  value={answer}
                  onChange={(e) => setAnswer(e.target.value)}
                  rows={4}
                  placeholder="Type your answer here..."
                />
              )}
              <Space>
                <Button type="primary" onClick={onSubmit} disabled={remaining === 0} style={{ width: '100%' }}>Submit answer</Button>
              </Space>
              <div>
                {interview.questions.slice(0, interview.currentIndex).map((q: Question) => (
                  <div key={q.id} style={{ marginTop: 8 }}>
                    <Tag color={q.difficulty === 'easy' ? 'green' : q.difficulty === 'medium' ? 'orange' : 'red'}>{q.difficulty.toUpperCase()}</Tag>
                    {q.score != null && (
                      <Typography.Text style={{ marginLeft: 8 }}>Score: {q.score}/10</Typography.Text>
                    )}
                    {q.feedback && (
                      <Typography.Paragraph style={{ margin: 0 }}>Feedback: {q.feedback}</Typography.Paragraph>
                    )}
                  </div>
                ))}
                {interview.complete && candidate?.profile.finalScore != null && (
                  <Typography.Paragraph>
                    Final Score: {candidate.profile.finalScore} — {candidate.profile.summary}
                  </Typography.Paragraph>
                )}
              </div>
            </Space>
          </Col>
          <Col xs={24} md={8}>
            <Typography.Title level={5}>Chat</Typography.Title>
            <List
              size="small"
              bordered
              dataSource={chatMessages.slice(-10)}
              renderItem={(m: typeof chatMessages[number]) => (
                <List.Item>
                  <Typography.Text strong style={{ marginRight: 8 }}>{m.role.toUpperCase()}:</Typography.Text>
                  <Typography.Text>{m.content}</Typography.Text>
                </List.Item>
              )}
              style={{ maxHeight: 300, overflow: 'auto' }}
            />
          </Col>
        </Row>
      ) : (
        <Alert type="success" message="Interview finished!" />
      )}
      <Modal
        title="Your Result"
        open={resultOpen}
        onOk={() => setResultOpen(false)}
        onCancel={() => setResultOpen(false)}
        okText="Close"
        cancelButtonProps={{ style: { display: 'none' } }}
      >
        {candidate?.profile.finalScore != null ? (
          <Space direction="vertical">
            <Typography.Title level={4} style={{ margin: 0 }}>Score: {candidate.profile.finalScore}</Typography.Title>
            {candidate.profile.summary && <Typography.Paragraph>{candidate.profile.summary}</Typography.Paragraph>}
          </Space>
        ) : (
          <Typography.Paragraph>Calculating your result...</Typography.Paragraph>
        )}
      </Modal>
    </Card>
  )
}
